package chicala.convert.backend.lean4

import scala.tools.nsc.Global

import chicala.ast.ChicalaAst
import chicala.convert.backend.util._

trait LeanEmitter extends CodeLinesImplicit { self: ChicalaAst =>
  val global: Global
  import global._

  object EmitLean {
    def apply(moduleDef: ModuleDef): String = {
      moduleDefToCode(moduleDef).toCode
    }
  }

  private var currentPkg: String = ""

  private def moduleDefToCode(moduleDef: ModuleDef): CodeLines = {
    currentPkg = moduleDef.pkg

    val moduleName = moduleDef.name.toString()
    val inputsName = moduleName + "Inputs"
    val outputsName = moduleName + "Outputs"
    val regsName = moduleName + "Regs"
    val stateName = moduleName + "State"
    val transName = s"${moduleName.head.toLower}${moduleName.tail}Trans"

    val params = moduleDef.vparams.map(v => s"${v.name} : ${sTypeToLean(v.tpe)}")

    val ioDef = moduleDef.ioDef
    val ioSignals = ioDef.tpe.flatten(ioDef.name.toString())
    val inputSignals = ioSignals.filter { case (_, tpe) => tpe.isInput }
    val outputSignals = ioSignals.filter { case (_, tpe) => tpe.isOutput }

    val regSignals = moduleDef.regDefs
      .map { case RegDef(name, tpe, _, _, _) => tpe.flatten(name.toString()) }
      .flatten

    val wireDefs = moduleDef.body.collect { case w: WireDef => w }
    val nodeDefs = moduleDef.body.collect { case n: NodeDef => n }

    val stateSignals = {
      val fields = scala.collection.mutable.LinkedHashMap.empty[String, SignalType]
      outputSignals.foreach { case (name, tpe) => fields.update(name, tpe) }
      regSignals.foreach { case (name, tpe) => fields.update(name + "_next", tpe) }
      wireDefs.foreach { case WireDef(name, tpe, _, _) => fields.update(name.toString(), tpe) }
      nodeDefs.foreach { case NodeDef(name, tpe, _, _) => fields.update(name.toString(), tpe) }
      fields.toList
    }

    val header = CodeLines(
      s"""/-
         |  Lean4 model generated by Chicala (prototype).
         |-/
         |
         |import Std
         |
         |namespace ${moduleDef.pkg}
         |
         |/-- Interpret a 1-bit bitvector as a Boolean guard. -/
         |def bv1IsTrue (v : BitVec 1) : Bool :=
         |  v != 0
         |
        |/-- Convert Bool into a 1-bit bitvector. -/
        |def boolToBv1 (b : Bool) : BitVec 1 :=
        |  if b then (BitVec.ofNat 1 1) else (BitVec.ofNat 1 0)
        |
        |/-- Select an element from a list (Vec). -/
        |def vecSelect {α : Type} (xs : List α) (i : Nat) : α :=
        |  xs.get! i
        |
        |/-- Update an element in a list (Vec). -/
        |def vecUpdate {α : Type} (xs : List α) (i : Nat) (v : α) : List α :=
        |  xs.set! i v
        |
        |/-- Bitvector concatenation. -/
        |opaque bvCat {w1 w2 : Nat} (a : BitVec w1) (b : BitVec w2) : BitVec (w1 + w2)
        |
        |/-- Bitvector slice (hi downto lo). -/
        |opaque bvSlice {w : Nat} (a : BitVec w) (hi lo : Nat) : BitVec (hi - lo + 1)
        |""".stripMargin
    )

    val inputsStruct = structDef(inputsName, params, inputSignals)
    val outputsStruct = structDef(outputsName, params, outputSignals)
    val regsStruct = structDef(regsName, params, regSignals)
    val stateStruct = structDef(stateName, params, stateSignals)

    val transDef = transDefCL(
      transName,
      params,
      inputsName,
      outputsName,
      regsName,
      stateName,
      inputSignals,
      outputSignals,
      regSignals,
      wireDefs,
      nodeDefs,
      stateSignals,
      moduleDef.body
    )

    CodeLines(
      header,
      inputsStruct,
      CodeLines.blank,
      outputsStruct,
      CodeLines.blank,
      regsStruct,
      CodeLines.blank,
      stateStruct,
      CodeLines.blank,
      transDef,
      CodeLines.blank,
      s"end ${moduleDef.pkg}"
    )
  }

  private def structDef(
      structName: String,
      params: List[String],
      signals: List[(String, SignalType)]
  ): CodeLines = {
    val fields = signals.map { case (name, tpe) => s"${name} : ${signalTypeToLean(tpe)}" }

    if (fields.isEmpty)
      CodeLines(s"structure ${structName}${paramsSignature(params)} where")
    else
      CodeLines(
        s"structure ${structName}${paramsSignature(params)} where",
        fields.toCodeLines.indented
      )
  }

  private def transDefCL(
      transName: String,
      params: List[String],
      inputsName: String,
      outputsName: String,
      regsName: String,
      stateName: String,
      inputSignals: List[(String, SignalType)],
      outputSignals: List[(String, SignalType)],
      regSignals: List[(String, SignalType)],
      wireDefs: List[WireDef],
      nodeDefs: List[NodeDef],
      stateSignals: List[(String, SignalType)],
      body: List[MStatement]
  ): CodeLines = {
    val inputsArg = s"(inputs : ${inputsName}${paramsUse(params)})"
    val regsArg = s"(regs : ${regsName}${paramsUse(params)})"
    val returnType = s"${outputsName}${paramsUse(params)} × ${regsName}${paramsUse(params)}"

    val initState = initStateCL(
      stateName,
      params,
      outputSignals,
      regSignals,
      wireDefs,
      nodeDefs,
      stateSignals
    )

    val (finalStateName, bodyCL) = applyStatementsCL(body, "st0")

    val outputsMk = mkStruct(outputsName, params, outputSignals.map(_._1), finalStateName)
    val regsMk = mkStruct(regsName, params, regSignals.map(_._1 + "_next"), finalStateName)

    CodeLines(
      s"def ${transName}${paramsSignature(params)} ${inputsArg} ${regsArg} : ${returnType} :=",
      CodeLines(
        initState,
        bodyCL,
        s"(${outputsMk}, ${regsMk})"
      ).indented
    )
  }

  private def initStateCL(
      stateName: String,
      params: List[String],
      outputSignals: List[(String, SignalType)],
      regSignals: List[(String, SignalType)],
      wireDefs: List[WireDef],
      nodeDefs: List[NodeDef],
      stateSignals: List[(String, SignalType)]
  ): CodeLines = {
    val initMap = scala.collection.mutable.Map.empty[String, String]

    outputSignals.foreach { case (name, tpe) =>
      initMap.update(name, signalDefault(tpe))
    }
    regSignals.foreach { case (name, _) =>
      initMap.update(name + "_next", s"regs.${name}")
    }
    wireDefs.foreach { case WireDef(name, tpe, someInit, _) =>
      val init = someInit.map(mTermToLean(_, "st0", leftSide = false)).getOrElse(signalDefault(tpe))
      initMap.update(name.toString(), init)
    }
    nodeDefs.foreach { case NodeDef(name, tpe, rhs, _) =>
      initMap.update(name.toString(), mTermToLean(rhs, "st0", leftSide = false))
    }

    val initFields = stateSignals.map { case (name, tpe) =>
      val init = initMap.getOrElse(name, signalDefault(tpe))
      s"${name} := ${init}"
    }

    val initLines = CodeLines(
      initFields
        .map(x => s"${x}")
        .toCodeLines
        .enddedWithExceptLast(",")
        .indented
    )

    CodeLines(
      s"let st0 : ${stateName}${paramsUse(params)} :=",
      CodeLines(
        s"{",
        initLines,
        s"}"
      ).indented
    )
  }

  private def mkStruct(structName: String, params: List[String], fieldNames: List[String], stateName: String): String = {
    val typeName = s"${structName}${paramsUse(params)}"
    if (fieldNames.isEmpty) {
      s"({} : ${typeName})"
    } else {
      val args = fieldNames.map(n => s"${n} := ${stateName}.${n}").mkString("{ ", ", ", " }")
      s"(${args} : ${typeName})"
    }
  }

  private def applyStatementsCL(body: List[MStatement], startState: String): (String, CodeLines) = {
    val statements = body.filterNot {
      case _: IoDef  => true
      case _: RegDef => true
      case _: WireDef => true
      case _: SValDef => true
      case _: SDefDef => true
      case _: EnumDef => true
      case _: SUnapplyDef => true
      case _: SubModuleDef => true
      case _ => false
    }

    var idx = 0
    var curState = startState
    val lines = statements.map { stmt =>
      idx += 1
      val nextState = s"st${idx}"
      val cl = statementToStateUpdate(stmt, curState, nextState)
      curState = nextState
      cl
    }.toCodeLines

    (curState, lines)
  }

  private def statementToStateUpdate(stmt: MStatement, fromState: String, toState: String): CodeLines = {
    stmt match {
      case c: Connect =>
        c.left match {
          case CApply(VecSelect, _, operands) if operands.length >= 2 =>
            val vecName = mTermToLean(operands.head, fromState, leftSide = true)
            val idxExpr = mTermToLean(operands.tail.head, fromState, leftSide = false)
            val leftWidth = signalWidthFromTerm(c.left)
            val rightExpr = c.expr match {
              case l: Lit => litLeanWithWidth(l, leftWidth)
              case _      => mTermToLean(c.expr, fromState, leftSide = false)
            }
            val currentVec = s"${fromState}.${vecName}"
            val updateExpr = s"vecUpdate ${currentVec} (${idxExpr}).toNat ${rightExpr}"
            CodeLines(s"let ${toState} := { ${fromState} with ${vecName} := ${updateExpr} }")
          case _ =>
            val leftName = mTermToLean(c.left, fromState, leftSide = true)
            val leftWidth = signalWidthFromTerm(c.left)
            val rightExpr = c.expr match {
              case l: Lit => litLeanWithWidth(l, leftWidth)
              case _      => mTermToLean(c.expr, fromState, leftSide = false)
            }
            CodeLines(s"let ${toState} := { ${fromState} with ${leftName} := ${rightExpr} }")
        }
      case w: When =>
        val cond = mTermToLean(w.cond, fromState, leftSide = false)
        val whenExpr = branchExpr(w.whenp, fromState, s"${toState}w")
        val otherExpr = if (w.otherp.isEmpty) CodeLines(fromState) else branchExpr(w.otherp, fromState, s"${toState}o")
        CodeLines(
          s"let ${toState} := if bv1IsTrue (${cond}) then",
          whenExpr.indented,
          s"else",
          otherExpr.indented
        )
      case s: Switch =>
        val cond = mTermToLean(s.cond, fromState, leftSide = false)
        val branches = s.branchs.zipWithIndex.map { case ((v, body), i) =>
          val vExpr = mTermToLean(v, fromState, leftSide = false)
          val bExpr = branchExpr(body, fromState, s"${toState}b${i}")
          CodeLines(
            s"if (${cond} == ${vExpr}) then",
            bExpr.indented,
            s"else"
          )
        }
        val defaultExpr = CodeLines(fromState)
        val expr = branches.foldRight(defaultExpr) { case (cl, acc) =>
          CodeLines(cl, acc.indented)
        }
        CodeLines(
          s"let ${toState} :=",
          expr.indented
        )
      case n: NodeDef =>
        val rhs = mTermToLean(n.rhs, fromState, leftSide = false)
        CodeLines(s"let ${toState} := { ${fromState} with ${n.name.toString()} := ${rhs} }")
      case s: SubModuleRun =>
        subModuleRunCL(s, fromState, toState)
      case _ =>
        CodeLines(s"let ${toState} := ${fromState}")
    }
  }

  private def branchExpr(stmt: MStatement, stateName: String, prefix: String): CodeLines = {
    stmt match {
      case s: SBlock =>
        val (finalState, updates) = applyStatementsCL(s.body, stateName)
        CodeLines(
          updates,
          finalState
        )
      case x =>
        val tmpState = s"${prefix}1"
        val update = statementToStateUpdate(x, stateName, tmpState)
        CodeLines(
          update,
          tmpState
        )
    }
  }

  private def signalTypeToLean(tpe: SignalType): String = tpe match {
    case Bool(_, _) => "BitVec 1"
    case UInt(width, _, _) => s"BitVec ${widthToLean(width)}"
    case SInt(width, _, _) => s"BitVec ${widthToLean(width)}"
    case Vec(_, _, tparam) => s"List ${signalTypeToLean(tparam)}"
    case _ => "BitVec 1"
  }

  private def widthToLean(width: CSize): String = width match {
    case KnownSize(w) => sTermToLean(w)
    case _ => "1"
  }

  private def sTypeToLean(tpe: SType): String = tpe match {
    case StInt => "Nat"
    case StBigInt => "Nat"
    case StBoolean => "Bool"
    case StUnit => "Unit"
    case _ => "Nat"
  }

  private def signalDefault(tpe: SignalType): String = tpe match {
    case Bool(_, _) => "(BitVec.ofNat 1 0)"
    case UInt(width, _, _) => s"(BitVec.ofNat ${widthToLean(width)} 0)"
    case SInt(width, _, _) => s"(BitVec.ofNat ${widthToLean(width)} 0)"
    case Vec(size, _, tparam) => s"List.replicate ${widthToLean(size)} ${signalDefault(tparam)}"
    case _ => "0"
  }

  private def mTermToLean(mTerm: MTerm, stateName: String, leftSide: Boolean): String = mTerm match {
    case s: SignalRef => signalRefLean(s, stateName, leftSide)
    case c: CApply => cApplyLean(c, stateName)
    case l: Lit => litLean(l)
    case a: Assert => s"${mTermToLean(a.exp, stateName, leftSide = false)}"
    case s: SApply => sApplyLean(s, stateName)
    case s: SSelect => sSelectLean(s, stateName)
    case s: STuple => s"(${s.args.map(mTermToLean(_, stateName, leftSide = false)).mkString(", ")})"
    case s: SLiteral => sLiteralLean(s)
    case SIdent(name, _) => name.toString()
    case s: SIf => s"(if ${mTermToLean(s.cond, stateName, leftSide = false)} then ${mTermToLean(s.thenp, stateName, leftSide = false)} else ${mTermToLean(s.elsep, stateName, leftSide = false)})"
    case s: SBlock => ""
    case s: SAssign => ""
    case EmptyMTerm => ""
    case _ => "0"
  }

  private def signalRefLean(signalRef: SignalRef, stateName: String, leftSide: Boolean): String = {
    def getNameFromTree(tree: Tree): String = tree match {
      case Ident(name)             => name.toString()
      case Select(This(_), name)   => name.toString()
      case Select(qualifier, name) => s"${getNameFromTree(qualifier)}_${name}"
      case _ => "unknown"
    }
    val baseName = getNameFromTree(signalRef.name)
    if (signalRef.tpe.isReg) {
      if (leftSide) s"${baseName}_next" else s"regs.${baseName}"
    } else if (signalRef.tpe.isInput) {
      s"inputs.${baseName}"
    } else if (leftSide) {
      baseName
    } else {
      s"${stateName}.${baseName}"
    }
  }

  private def cApplyLean(cApply: CApply, stateName: String): String = {
    val operands = cApply.operands.map(mTermToLean(_, stateName, leftSide = false))
    cApply.op match {
      case VecSelect =>
        if (operands.length >= 2) s"vecSelect ${operands(0)} (${operands(1)}).toNat"
        else "0"
      case Add => s"(${operands(0)} + ${operands(1)})"
      case Minus => s"(${operands(0)} - ${operands(1)})"
      case Multiply => s"(${operands(0)} * ${operands(1)})"
      case And => s"(${operands(0)} &&& ${operands(1)})"
      case Or => s"(${operands(0)} ||| ${operands(1)})"
      case Xor => s"(${operands(0)} ^^^ ${operands(1)})"
      case LShift => s"(${operands(0)} <<< ${operands(1)})"
      case RShift => s"(${operands(0)} >>> ${operands(1)})"
      case Equal => s"boolToBv1 (${operands(0)} = ${operands(1)})"
      case NotEqual => s"boolToBv1 (${operands(0)} != ${operands(1)})"
      case GreaterEq => s"boolToBv1 (${operands(0)} >= ${operands(1)})"
      case LogiAnd => s"(${operands(0)} &&& ${operands(1)})"
      case LogiOr => s"(${operands(0)} ||| ${operands(1)})"
      case LogiNot => s"(~~~${operands(0)})"
      case Not => s"(~~~${operands(0)})"
      case Negative => s"(-${operands(0)})"
      case Mux => s"(if bv1IsTrue (${operands(0)}) then ${operands(1)} else ${operands(2)})"
      case Cat =>
        if (operands.isEmpty) "0"
        else operands.reduceLeft((a, b) => s"bvCat ${a} ${b}")
      case Slice =>
        if (operands.length >= 3) s"bvSlice ${operands(0)} (${operands(1)}).toNat (${operands(2)}).toNat"
        else "0"
      case _ => "0"
    }
  }

  private def litLean(lit: Lit): String = {
    val literal = mTermToLean(lit.litExp, "st0", leftSide = false)
    val width = lit.tpe match {
      case Bool(_, _) => "1"
      case UInt(w, _, _) => widthToLean(w)
      case SInt(w, _, _) => widthToLean(w)
    }
    s"(BitVec.ofNat ${width} ${literal})"
  }

  private def litLeanWithWidth(lit: Lit, widthOpt: Option[String]): String = {
    val literal = mTermToLean(lit.litExp, "st0", leftSide = false)
    val width = lit.tpe match {
      case Bool(_, _) => "1"
      case UInt(w, _, _) => if (isInferredWidth(w)) widthOpt.getOrElse(widthToLean(w)) else widthToLean(w)
      case SInt(w, _, _) => if (isInferredWidth(w)) widthOpt.getOrElse(widthToLean(w)) else widthToLean(w)
    }
    s"(BitVec.ofNat ${width} ${literal})"
  }

  private def sLiteralLean(sLiteral: SLiteral): String = sLiteral.tpe match {
    case StString => "\"\""
    case _ => sLiteral.value.toString()
  }

  private def sApplyLean(sApply: SApply, stateName: String): String = {
    val args = sApply.args.map(mTermToLean(_, stateName, leftSide = false))
    sApply.fun match {
      case SSelect(from, name, _) =>
        val fromStr = mTermToLean(from, stateName, leftSide = false)
        val n = name.toString()
        n match {
          case "+" => s"(${fromStr} + ${args.head})"
          case "-" => s"(${fromStr} - ${args.head})"
          case "*" => s"(${fromStr} * ${args.head})"
          case "/" => s"(${fromStr} / ${args.head})"
          case "%" => s"(${fromStr} % ${args.head})"
          case _ => s"(${fromStr} ${n} ${args.mkString(" ")})"
        }
      case SIdent(name, _) => s"${name} ${args.mkString(" ")}".trim
      case _ => s"${args.mkString(" ")}".trim
    }
  }

  private def sSelectLean(sSelect: SSelect, stateName: String): String = {
    val from = mTermToLean(sSelect.from, stateName, leftSide = false)
    val name = sSelect.name.toString()
    s"${from}.${name}"
  }

  private def sTermToLean(term: STerm): String = term match {
    case SLiteral(value, _) => value.toString()
    case SIdent(name, _) => name.toString()
    case s: SApply => sApplyLean(s, "st0")
    case s: SSelect => sSelectLean(s, "st0")
    case _ => "1"
  }

  private def paramsSignature(params: List[String]): String = {
    if (params.isEmpty) "" else params.map(p => s"(${p})").mkString(" ")
  }

  private def paramsUse(params: List[String]): String = {
    val names = params.map(_.takeWhile(_ != ':').trim).filter(s => s.length > 0)
    if (names.isEmpty) "" else names.mkString(" ", " ", "")
  }

  private def isInferredWidth(width: CSize): Boolean = width match {
    case InferredSize => true
    case UnknownSize  => true
    case _            => false
  }

  private def signalWidthFromTerm(term: MTerm): Option[String] = term match {
    case SignalRef(_, tpe) => signalWidthFromType(tpe)
    case _                 => None
  }

  private def signalWidthFromType(tpe: SignalType): Option[String] = tpe match {
    case Bool(_, _)          => Some("1")
    case UInt(w, _, _)       => Some(widthToLean(w))
    case SInt(w, _, _)       => Some(widthToLean(w))
    case _                   => None
  }

  private def subModuleRunCL(subModuleRun: SubModuleRun, fromState: String, toState: String): CodeLines = {
    val (pkgOpt, modName) = splitModuleName(subModuleRun.moduleType.fullName)
    val prefix = pkgOpt.filter(_ != currentPkg).map(_ + ".").getOrElse("")
    val transName = prefix + lowerName(modName) + "Trans"
    val inputsName = prefix + modName + "Inputs"
    val regsName = prefix + modName + "Regs"

    val inputFields = subModuleRun.inputSignals.zip(subModuleRun.inputRefs).map {
      case ((name, _), ref) =>
        s"${name} := ${mTermToLean(ref, fromState, leftSide = false)}"
    }
    val inputsExpr =
      if (inputFields.isEmpty) s"({} : ${inputsName})"
      else s"({ ${inputFields.mkString(", ")} } : ${inputsName})"

    val regsExpr = s"({} : ${regsName})"
    val outputsName = s"${toState}SubOut"

    var lastState = fromState
    val updatesCL = subModuleRun.outputSignals.zip(subModuleRun.outputNames).map {
      case ((name, _), outName) =>
        val nextState = s"${toState}_${name}"
        val update = s"let ${nextState} := { ${lastState} with ${outName.toString()} := ${outputsName}.${name} }"
        lastState = nextState
        CodeLines(update)
    }.toCodeLines

    val finalState = if (lastState == fromState) fromState else lastState

    CodeLines(
      s"let (${outputsName}, _) := ${transName} ${inputsExpr} ${regsExpr}",
      updatesCL,
      s"let ${toState} := ${finalState}"
    )
  }

  private def splitModuleName(fullName: String): (Option[String], String) = {
    val parts = fullName.split("\\.").toList
    parts match {
      case Nil          => (None, fullName)
      case last :: Nil  => (None, last)
      case _ =>
        val modName = parts.last
        val pkgName = parts.init.mkString(".")
        (Some(pkgName), modName)
    }
  }

  private def lowerName(name: String): String = {
    if (name.isEmpty) name else s"${name.head.toLower}${name.tail}"
  }
}
